## 基础
1. make和new的区别
    - make 只能用来分配及初始化类型为 `slice、map、chan` 的数据。new 可以分配任意类型的数据
    - new 分配返回的是`指针`，即类型 *T。make 返回引用，即 T
    - new 分配的空间被清零。make 分配空间后，会进行初始化

2. 数组和切片的区别
    - array
      - 是固定长度的数组，使用前必须确定数组长度。
      - `值类型`。作为函数的参数，实际传递的是一份数组的拷贝
      - array的长度也是Type的一部分
    - slice
      - `引用类型`，是一个动态指向数组切片的指针，作为函数的参数，传递的是指针
      - 是一个不定长，总是指向底层的数组array的数据结构

3. for range 的时候它的地址会发生变化么？
    - 值拷贝，地址不会变

4. for 循环遍历slice有什么问题
    - 循环次数在循环开始前已经确定
    - 循环的时候会创建每个元素的副本
    - 循环的时候短声明只会在开始时执行一次，后面都是重用

5. go defer多个 defer 的顺序，defer 在什么时机会修改返回值？（for defer），defer recover 的问题？(主要是能不能捕获)
    - go defer是一个`栈`的关系，执行的顺序是 `后进先出`
    - 返回值列表声明了返回值名称和类型，defer会修改返回值
    - recover可以终止panic造成的程序崩溃。它只一个只能在defer中发挥作用的函数，在其他作用域中调用不会发挥作用

6. uint 类型溢出
    - unit运算后溢出不会抛出任何异常，会返回意料之外的结果

7. 介绍 rune 类型
    - type byte = uint8
    - type rune = int32
    - rune类型实质其实就是int32，代表一个 UTF-8 字符，他是go语言内在处理字符串及其便捷的字符单位

8. golang 中解析 tag 是怎么实现的？反射原理是什么？(问的很少，但是代码中用的多)
    - tag通过反射去实现
    - 反射通过接口实现，通过隐式转换，普通类型被转换为interface类型，再从inerface类型转换为反射类型，再从反射类型得到想要的类型和值信息

9. 调用函数传入结构体时，应该传值还是指针？ （Golang 都是值传递）
    - 如果是需要修改原结构体的值，需要传指针
    - 传值不会修改原始结构体的值

10. silce 遇到过哪些坑？
    - 每次对slice做append操作后，这个slice可能更换了引用的数组

11. go struct 能不能比较？
12. Go 闭包

## Context