## 1.1 MySQL逻辑架构
- 最上层：连接/线程处理
- 第二层：查询解析、分析、优化、缓存以及所有内置函数等
- 第三层：存储引擎

## 1.2 并发控制
### 1.2.1 读写锁
也叫`共享锁`和`排他锁`

### 1.2.2 锁粒度
- 表锁
- 行级锁

## 1.3 事务
ACID
- 原子性
- 一致性
- 隔离性
- 持久性
### 1.3.1 隔离级别
- READ UNCOMMITED（未提交读）
  - 较少使用
  - 容易产生 `脏读`
- READ COMMITED（提交读）
- REPEATABLE READ（可重复读）
  - 解决脏读问题
  - 会产生 `幻读`
  - 可以通过 `多版本控制（MVCC）` 解决幻读问题
- SERIALIZABLE（可串行化）
  - 最高隔离级别
  - 较少用

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| - | - | - | - | - | 
|READ UNCOMMITED（未提交读）| ✅ | ✅ | ✅|  ❌ |
| READ COMMITED（提交读） | ❌ | ✅ |✅ | ❌|
|REPEATABLE READ（可重复读） | ❌ | ❌ | ✅ | ❌ |
|SERIALIZABLE（可串行化） |❌ |❌ |❌ |✅ |

### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。  

InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚

## 1.4 多版本并发控制（MVCC）
在REPEATABLE_READ隔离级别下，MVCC具体操作方式：  
**SELECT**  
- InnoDB会根据以下两个条件检查每行记录：  
    1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的
    2. 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除  

只有符合上述两个条件的记录，才能返回作为查询结果

**INSERT**  
- InnoDB为新插入的每一行保存当前系统版本号作为行版本号

**DELETE**  
- InnoDB为删除的每一行保存当前系统版本号作为行删除标识

**UPDATE**  
- InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的的行作为删除标识

MVCC只在REAPETABLE READ和READ COMMITED两个隔离级别下工作

## 1.5 MySQL的存储引擎
### 1.5.1 InnoDB存储引擎
1. `事务型`存储引擎
2. 采用`MVCC`来支持高并发，并且实现了四个标准的隔离级别，默认级别是REPEATABLE READ（可重复读）
3. 通过`间隙锁`策略防止`幻读`
4. 基于`聚簇索引`建立
5. 支持真正的`热备份`