## 1.1 MySQL逻辑架构
- 最上层：连接/线程处理
- 第二层：查询解析、分析、优化、缓存以及所有内置函数等
- 第三层：存储引擎

## 1.2 并发控制
### 1.2.1 读写锁
也叫`共享锁`和`排他锁`

### 1.2.2 锁粒度
- 表锁
- 行级锁

## 1.3 事务
ACID
- 原子性
- 一致性
- 隔离性
- 持久性
### 1.3.1 隔离级别
- READ UNCOMMITED（未提交读）
  - 较少使用
  - 容易产生 `脏读`
- READ COMMITED（提交读）
- REPEATABLE READ（可重复读）
  - 解决脏读问题
  - 会产生 `幻读`
  - 可以通过 `多版本控制（MVCC）` 解决幻读问题
- SERIALIZABLE（可串行化）
  - 最高隔离级别
  - 较少用

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| - | - | - | - | - | 
|READ UNCOMMITED（未提交读）| ✅ | ✅ | ✅|  ❌ |
| READ COMMITED（提交读） | ❌ | ✅ |✅ | ❌|
|REPEATABLE READ（可重复读） | ❌ | ❌ | ✅ | ❌ |
|SERIALIZABLE（可串行化） |❌ |❌ |❌ |✅ |

### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。  

InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚