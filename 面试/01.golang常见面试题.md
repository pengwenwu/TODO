## 基础
1. make和new的区别
    - make 只能用来分配及初始化类型为 `slice、map、chan` 的数据。new 可以分配任意类型的数据
    - new 分配返回的是`指针`，即类型 *T。make 返回引用，即 T
    - new 分配的空间被清零。make 分配空间后，会进行初始化

2. 数组和切片的区别
    - array
      - 是固定长度的数组，使用前必须确定数组长度。
      - `值类型`。作为函数的参数，实际传递的是一份数组的拷贝
      - array的长度也是Type的一部分
    - slice
      - `引用类型`，是一个动态指向数组切片的指针，作为函数的参数，传递的是指针
      - 是一个不定长，总是指向底层的数组array的数据结构

3. for range 的时候它的地址会发生变化么？
    - 值拷贝，地址不会变

4. for 循环遍历slice有什么问题
    - 循环次数在循环开始前已经确定
    - 循环的时候会创建每个元素的副本
    - 循环的时候短声明只会在开始时执行一次，后面都是重用

5. go defer多个 defer 的顺序，defer 在什么时机会修改返回值？（for defer），defer recover 的问题？(主要是能不能捕获)
    - go defer是一个`栈`的关系，执行的顺序是 `后进先出`
    - 返回值列表声明了返回值名称和类型，defer会修改返回值
    - recover可以终止panic造成的程序崩溃。它只一个只能在defer中发挥作用的函数，在其他作用域中调用不会发挥作用

6. uint 类型溢出
    - unit运算后溢出不会抛出任何异常，会返回意料之外的结果

7. 介绍 rune 类型
    - type byte = uint8
    - type rune = int32
    - rune类型实质其实就是int32，代表一个 UTF-8 字符，他是go语言内在处理字符串及其便捷的字符单位

8. golang 中解析 tag 是怎么实现的？反射原理是什么？(问的很少，但是代码中用的多)
    - tag通过反射去实现
    - 反射通过接口实现，通过隐式转换，普通类型被转换为interface类型，再从inerface类型转换为反射类型，再从反射类型得到想要的类型和值信息

9. 调用函数传入结构体时，应该传值还是指针？ （Golang 都是值传递）
    - 如果是需要修改原结构体的值，需要传指针
    - 传值不会修改原始结构体的值

10. silce 遇到过哪些坑？
    - 每次对slice做append操作后，这个slice可能更换了引用的数组

11. go struct 能不能比较？
    - 有时候可以比较，有时候不可以比较
      - 当其基本类型包含：slice, map, function时，不能直接比较
      - 同一个struct的两个相同实例，如果成员变量包含指针变量或者带有不能比较的成员，也是不可以直接比较
      - 不同的结构体，相同的值内容，可以通过强制转换后比较。当然，如果包含不可比较类型，也是不可比较的
    - 如果必须要比较，可以通过反射方法`reflect.DeepEqual`去比较
    - struct必须时可比较的，才能作为map的key

12. Go 闭包
    - 闭包是由函数及其相关的引用环境组合而成的实体（即：闭包=函数+引用环境）
    - 闭包可能会导致变量逃逸到堆上来延长变量的生命周期，给gc带来压力
    - 内函数对外函数的变量的修改，是对变量的引用。共享在一个堆上的变量。变量被引用后，它所在的函数结束，这变量也不会马上被销毁。相当于变相延长了函数的生命周期
    - 在for循环的时候，如果闭包使用的是外部的变量，那函数输出的结果依赖于子协程执行时的那一刻的变量值
    - 当clousure所在的函数重新调用时，其closure是新的，其context引用的变量也是重新在heap定义过的
    - defer调用会在当前函数执行结束前才被执行，这些调用被称为延迟调用。defer中使用匿名函数依然是一个闭包

## Context相关
`context`用来解决`goroutine`之间的`退出通知`、`元数据传递`的功能
1. context 结构是什么样的？
    - context是一个接口，定义了四个需要实现的方法：
        - `Deadline` - 返回context.Context被取消的时间，也就是完成工作的截止日期
        - `Done` - 返回一个只读Channel，这个Channel会在当前工作时间完成或者上下文被取消后关闭，多次调用Done方法会返回同一个Channel
        - `Err` - 返回context.Context结束的原因，它只会在Done方法对应的Channel关闭时返回非空的值：
            - 如果context.Context被取消，会返回`Canceled`错误
            - 如果context.Context超时，会返回`DeadlineExceeded`错误
        - `Value` -  从context.Context中获取键对应的值，对于同一个上下文来说，多次调用Value并传入相同的Key会返回相同的结果，该方法可以用来传递请求特定的数据
```go
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
```
2. context 使用场景和用途？（基本必问）
    - 主要用于在 goroutine 之间传递取消信号、超时时间、截止时间以及一些共享的值等

## Channel相关
1. channel 是否线程安全？锁用在什么地方？
    - channel是协程不是线程，如果理解为允许多个goroutine同时读写，那它是安全的
    - channel的核心是数据流动，关注到并发问题中的数据流动，把流动的数据放到channel中，就能使用channel解决这个并发问题
    - channel和mutex锁的选择
        - channel的能力是让数据流动起来，擅长的数据流动的场景：
            - 传递数据的所有权，即把某个数据发送给其他协程
            - 分发任务，每一个任务都是一个数据
            - 交流异步结果，结果是一个数据
        - mutex的能力时数据不动，某段时间只给一个协程访问数据的权限，擅长数据位置固定的场景
            - 缓存
            - 状态
2. go channel 的底层实现原理 （数据结构）
```go
type hchan struct {
	qcount uint // 队列中所有的数据总数
	dataqsize uint // 环形队列的size
	buf unsafe.Pointer // 指向dataqsize长度的数组
	elemsize uint16 // 元素大小
	closed uint32
	elemtype *_type // 元素类型
	sendx uint // 已发送的元素在环形队列中的位置
	recvx uint // 已接收的元素在环形队列中的位置
	recvq waitq // 接收者的等待队列
	sendq waitq // 发送者的等待队列

	lock mutex
}
```
![go channel 数据结构](http://pic.pwwtest.com/20220223112913.png)

3. nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型）
例如：go channel close 后读的问题
向为 nil 的 channel 发送数据会怎么样？
    - 关闭未初始化的channel(nil)会panic
    - 重复关闭同一个channel会panic
    - 向已关闭的channel发送消息会panic
    - 已关闭的channel，仍然可以从channel中读取剩余的数据，直到数据全部读取完成
    - 在一个值为nil的channel上发送或接收数据会导致永久堵塞
    - 在使用channel的时候，一个适用的原则是：不要从接收端关闭channel，也不要关闭有多个并发发送者的channel


4. 向 channel 发送数据和从 channel 读数据的流程是什么样的？
    - 写入数据的主要流程如下：
        - 如果接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq去除G，并把数据写入，最后讲G唤醒，结束发送过程
        - 如果缓冲区有空余位置，将数据写入缓冲区，结束发送过程
        - 如果缓冲区没有空余位置，讲发送数据写入G，讲当前G加入sendq，进入睡眠，等待被读goroutine唤醒
        - ![](http://pic.pwwtest.com/20220223112701.png)
    - 读取数据主要流程如下：
        - 没有缓冲区时，如果等待发送队列sendq不为空，直接从sendq中读取G，把G中数据读出，最后把G唤醒，结束读取过程
        - 有缓冲区时，如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中头部读出消息，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程
        - 如果缓冲区有数据，则从缓冲区中读取数据，结束读取过程
        - 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒
        - ![](http://pic.pwwtest.com/20220223113430.png)

## Map相关
map是设计一种数据结构来维护一个集合的数据，并且可以同时对集合进行增删改查的操作。最主要的数据结构有两种：`哈希查找表(Hash table)`、`搜索树(Search tree)`  

哈希查找表用一个哈希函数将key分配到不同的桶（bucket，也就是数组的不同index）。这样，开销主要是在哈希函数的计算以及数组的常数访问时间。很多场景下，哈希查找表的性能很高。

哈希查找表一般会存在“碰撞”问题，就是说不同的key被哈希到了同一个bucket。一般两种应对方法：`链表法`和`开放地址法`。`链表法`将一个bucket实现成一个链表，落在同一个bucket中的key都会插入到这个链表。`开放地址`则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的key。

搜索树法一般是采用自平衡搜索树，包括：AVL树，红黑树。

自平衡搜索树法的最差搜索效率是O(logN)，而哈希查找表最差是O(N)。当然，哈希查找表的平均查找效率是O(1)，如果哈希函数设计的很好，最坏情况基本不会出现。遍历自平衡搜索树，返回的key序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。

1. map 使用注意的点，并发安全？


2. map 循环是有序的还是无序的？
    - 无序

3. map 中删除一个 key，它的内存会释放么？
4. 怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？
5.  nil map 和空 map 有何不同？
6. map 的数据结构是什么？是怎么实现扩容？
    - map的结构体是hmap
    ```go
    // A header for a Go map.
    type hmap struct {
        count int // 元素个数，调用len(map)时，直接返回此值
        flags uint8
        B uint8 // buckets的对数log_2
        noverflow uint16 // overflow 的 bucket 近似数
        hash0 uint32 // 计算key的哈希的时候会传入哈希函数
        buckets unsafe.Pointer // 指向buckets的数组，大小为2^B。如果元素个数为0，就为nil
        oldbuckets unsafe.Pointer // 扩容的时候，buckets长度会是oldbuckets的两倍
        nevacuate uintptr // 指示扩容进度，小于此地址的buckets迁移完成
        extra *mapextra // optional fields
    }
    ```
    - ![](http://pic.pwwtest.com/20220224161005.png)
    - Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。因此，需要有一个指标来衡量前面描述的情况，这就是`装载因子`。Go 源码里这样定义 `装载因子`：
    ```go
    loadFactor := count / (2^B)
    ```
    - count就是map的元素个数，2^B表死bucket数量。在向map插入新key的时候，会进行条件检测，符合下面两个条件就会触发扩容：
        - 装载因子超过阈值，源码里定义的阈值时6.5
        - overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B >= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。

7. map 取一个 key，然后修改这个值，原 map 数据的值会不会变化

## GMP 相关
1. 什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的较少）
2. 进程、线程、协程有什么区别？
3. 抢占式调度是如何抢占的？
4. M 和 P 的数量问题？
5. 协程怎么退出？
6. map 如何顺序读取？

## 锁相关
1. 除了 mutex 以外还有那些方式安全读写共享变量？
2. Go 如何实现原子操作？
3. Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？
4. Mutex 有几种模式？
5. goroutine 的自旋占用资源如何解决
6. 读写锁底层是怎么实现的？

## 同步原语相关
1. [知道哪些 sync 同步原语？各有什么作用？](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/)
 
sync.pool 问的相对多些

2. sync.WaitGroup

## 并发相关
1. 怎么控制并发数？
2. 多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？
3. 如何优雅的实现一个 goroutine 池（百度、手写代码）
4. select 可以用于什么？
5. 主协程如何等其余协程完再操作？

## GC 相关
1. go gc 是怎么实现的？（必问）
2. go 是 gc 算法是怎么实现的？ （得物，出现频率低）
3. GC 中 stw 时机，各个阶段是如何解决的？ （百度）
4. GC 的触发时机？

## 内存相关
1. 谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？
2. 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？
3. 请简述 Go 是如何分配内存的？
Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？
4. 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？
5. 堆和栈的区别？
6. 当 go 服务部署到线上了，发现有内存泄露，该怎么处理？

## 微服务框架
1. go-micro 微服务架构怎么实现水平部署的，代码怎么实现？
2. 怎么做服务发现的

## 其他
1. go 实现单例的方式？
2. 项目中使用 go 遇到的坑？
3. client 如何实现长连接？

## 编程题
1. 3 个函数分别打印 cat、dog、fish，要求每个函数都要起一个 goroutine，按照 cat、dog、fish 顺序打印在屏幕上 100 次。
2. 如何优雅的实现一个 goroutine 池？

