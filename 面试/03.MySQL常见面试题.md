## 索引
1. mysql 中聚簇索引和非聚簇索引的区别？（基本必问）
   - 区别在于：叶子节点是否存放一整行记录
     - InnoDB主键使用聚簇索引，MyISAM不管是主键索引还是二级索引使用的都是非聚簇索引
   - 聚簇索引：将数据存储和索引放到一起，找到索引也就找到了数据
   - 非聚簇索引：讲数据存储与索引分开，索引结构的叶子结点指向数据对应的行
2. 是否用到了索引？（explain）
3. 索引失效的情况？
   - 违反最左前缀原则
   - 在索引列上做任何操作（计算、函数、转换类型）
   - 使用 != 或者 <>
   - 数据类型不一致（隐式转换）
   - OR
   - like前缀模糊搜索
   - order by违反最左前缀原则，包含非索引字段排序
   - group by违反最左前缀原则，包含非索引字段分组
4. 索引的分类？
   - 按数据结构分类可分为：B+树索引、Hash索引、Full-text索引
   - 按物理存储分类可分为：聚簇索引、二级索引（辅助索引）
     - 二级索引需要回表查询，查询效率低一点
   - 按逻辑角度分类可分为：主键索引、普通索引、复合索引
5. 索引的结构？b + 树和 b 树的区别？
   - B+树非叶子结点只存储键值信息，数据记录都放到叶子结点中。而B树的非叶子结点也存储数据。所以B+树的单个结点的数据量更小，在相同的磁盘I/O次数下，能查询到更多的结点
   - B+树所有叶子结点之间都采用单链表连接。适合MySQL中最常见的基于范围的顺序检索场景，而B树无法做到这一点
6. 如何在不影响业务的情况下给表增加一个字段，那如果是索引呢？
pt-online-schema-change
7. 索引为什么不使用 Hash 结构
   - 简单的行操作增删改查，确实hash更快一点。但是针对sql的范围查询需求，时间复杂度会退化到O(n)，而树结构依然能够保持O(log(n))的效率

## 锁
1. 如何用 mysql 实现一个乐观锁？
   - 使用version版本
   - 使用时间戳
2. 什么是悲观锁？怎么实现悲观锁？
   - 悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作的时候都要通过获取锁才能进行对相同数据的操作
   - 实现方式分为：共享锁和排他锁
      - 共享锁：关闭mysql的autocommit模式，通过事务处理（select LOCK IN SHARE MODE）
      - 排他锁：（select for update）
3. 判断一些 sql 是否产生锁？是什么锁？
   - 只要涉及到表的改动，都会触发锁
   - where中含有至少一个字段添加了索引，会触发行锁，否则就是表锁
4. 什么是死锁？怎么产生死锁？怎么解决？
   - 死锁：是指两个或者两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法继续推行下去。
5. select for update 一定要在事务中使用么？它什么情况下是行锁，什么情况下是表锁？

## 事务
1. 什么多版本并发控制？ 解决什么问题？（很重要）
   - MVCC：通过保存数据在某个时间点的快照来实现并发控制。
   - 解决了一下问题：
     - 1）读写之间阻塞的问题
     - 2）降低了死锁的概率
     - 3）解决一致性读的问题

2. 事务的特性是什么？
   - 原子性
   - 一致性
   - 隔离性
   - 持久性
3. 延伸：分布式事务
4. 事务的隔离级别，分别有什么问题？
读未提交. 读提交. 重复读. 序列化

## 其他
1. 说一下主从复制？读写分离可能出现什么问题？
   - 主从复制类型
     - 基于语句的复制
     - 基于行的复制
     - 混合类型的复制
   - 读写分离可能出现的问题
     - 主从同步有延迟，会导致数据同步的这段时间，主从数据不一致，从库无法查询到最新的数据
2. limit 和 offset 在大的偏移量的情况下如何优化呢？
   - 可以用过返回上一次查询到的最后一个主键值，where只筛选后面的数据
